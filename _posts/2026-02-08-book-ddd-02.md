---
title: Chapter 2. 아키텍처 개요 (WIP)
date: 2026-02-08
categories: [Book, 도메인 주도 개발 시작하기]
tags: [ddd]     # TAG names should always be lowercase
author: admin
# description: Short summary of the post.  # display on the home page for a list of post
toc: true
comments: false
# https://chirpy.cotes.page/posts/write-a-new-post/
# ⇒, →
---

<details>
<summary>작업 내용</summary>

1. 아키텍처
* 표현
    * UI 영역
    * 사용자의 요청을 받아 응용 영역에 전달 & 응용 영역의 처리 결과를 다시 사용자에게 전달
    * (예) 웹 브라우저, REST API
    * MVC의 controller에 해당
* 응용
    * 사용자에게 제공할 기능 구현
        * (예) 주문 등록, 주문 취소, 상품 상세 조회 등
    * 도메인 영역의 도메인 모델을 사용하여 기능 구현
    * MVC의 service에 해당
    * 로직을 직접 수행하기 보다는 도메인 모델에 로직 수행을 위임
* 도메인
    * 도메인 모델 구현
    * 핵심 로직 수행
* 인프라스트럭처
    * 구현 기술
    * DB 연동 처리, 메시징 큐 처리, REST API 호출, SMTP 구현 등
    * 표현, 응용, 도메인 영역은 구현기술을 사용할 코드를 직접 다루지 않아야 한다.

2. 계층 구조
* 표현 > 응용 > 도메인 > 인프라스트럭처 순서
* 상위 계층에서 하위 계층으로의 의존만 존재. 하위 계층은 상위 계층에 의존하지 않는다.
* 다만, 구현의 편리함을 위해 응용이 직접 인프라스트럭처 계층에 의존하는 등의 유연성은 가능

3. DIP
* dependency inversion principle (의존 역전 원칙)
* 고수준 모듈이 저수준 모듈에 의존하는 상황
    * 계층의 의존과 모듈의 의존은 분리해서 생각하기!
* 고수준 모듈 & 저수준 모듈
    * 고수준 모듈: 의미있는 단일 기능을 제공하는 모듈 (예) 가격 할인 계산
        * 보통 계층 구조에서 표현, 응용, 도메인에 해당
    * 저수준 모듈: 하위 기능을 실제로 구현 (예) 가격 할인 계산 시 필요한 고객 정보 DB에서 가져오기, Drools라는 기술 이용하기
        * 보통 계층 구조에서 인프라스트럭처에 해당
* 계층 구조에서 상위 계층이 하위 계층에 의존하게 된다면 2가지 문제가 존재
    * 특정 기술에 너무 의존적이 될 수 있음 (다른 기술로 변경하기 힘듦)
    * 테스트 하기 어려움
* DIP는 이를 해결하기 위해 고수준 모듈이 저수준 모듈을 의존하는 것이 아니라, 저수준 모듈이 고수준 모듈을 의존하도록 한다.
    * 추상화한 인터페이스를 사용
    * 고수준 모듈이 저수준 모듈에서 사용하고 싶은 기능을 인터페이스로 제공하고, 저수준 모듈은 이 인터페이스를 상속해서 인터페이스에 맞게 실제 구현을 수행한다.
* 테스트 문제 > 인터페이스를 상속하는 mock 객체를 생성해서 하면 됨! // 코드 예시
    * 실제로 DB 등에 연결되지 않더라도 테스트 가능
* 다른 기술을 사용하고 싶으면 인터페이스를 상속하는 다른 인프라스트럭처 객체를 만들면 된다.
* DIP 주의사항
    * 저수준 모듈에서 인터페이스 추출하지 않도록 주의
    * 추상화된 인터페이스는 고수준 모듈 관점에서 도출 필요
    * (예) DB의 CRUD를 추상화한 인터페이스 > 저수준
    * (예) 기능을 이용해 할인율을 도출하는 인터페이스 > 고수준
* 사용자 기술에 따라 완벽한 DIP를 적용하기 보다는 구현 기술에 의존적인 코드를 도메인에 일부 포함하는 것이 효과적일 때도 있다. 무조건 DIP를 시도하지 말고 DIP의 이점을 얻는 수준에서 이용하기
* 무조건 인프라스트럭처에 대한 의존을 없앨 필요는 없음
    * (예) 스프링이 제공하는 기능들 @Transactional 등
    * 구현의 편리함은 DIP의 장점만큼 중요하기 때문

4. 도메인 영역 구성요소
* entity
    * 고유 식별자 있는 객체
    * 자신만의 라이프 사이클 가짐
    * 도메인의 고유한 개념 표현 (주문, 회원, 상품 등)
    * 데이터 + “기능” 제공
        * 기능을 제공한다는 점에서 DB 관계형 모델의 엔터티와는 차이를 가짐
        * 기능을 캡슐화해서 데이터가 임의로 변경되는 것을 막음
* value
    * 고유 식별자 없는 객체
    * 개념적으로 하나의 값 표현 (주소, 금액 등)
    * 엔터티의 속성으로 사용할 뿐 아니라 다른 밸류 타입의 속성으로도 사용
* aggregate
    * 엔터티와 밸류를 연관된 것끼리 개념적으로 하나로 묶은 것 (일종의 카테고리)
    * (예) 주문 > 주문, 배송지 정보, 주문자, 주문 목록 등
    * 애그리 거트 군집에 속한 객체를 관리하는 “루트 엔터티” 존재
        * 루트 엔터티에서 애그리거트에 속해 있는 엔터티와 밸류 객체를 이용해 애그리거트가 구현해야 할 기능 제공
        * 애그리거트 단위로 구현을 캡슐화 > 객체 지향 구조의 상위 느낌...!
* repository
    * 엔터티를 조회하거나 저장하는 기능 제공
    * 이 리파지토리는 고수준 모듈이다! 조회, 저장하는데 필요한 기능을 추상화해서 제공한다.
    * (?) 어떻게 다른지 코드로 확인해보면 좋을 것 같음
    * (?) HBase > 테이블을 구분해서 저장할 필요 없음. 그렇기 때문에 도메인이나 리파지토리 단위가 mysql보다 커질 수 있지 않을까?
* domain service
    * 특정 엔터티에 속하지 않는 도메인 로직 제공 (공통 로직 느낌)
    * 여러 엔터티와 밸류를 필요로 하는 로직

5. 모듈 구조
* 아키텍처의 각 영역은 별도 패키지에 위치
* 도메인 모듈은 도메인에 속한 애그리거트를 기준으로 다시 패키지 구성
* 한 패키지에 너무 많은 타입이 몰려서 불편하지 않도록 하기
    * 대략 10-15개 미만의 타입 개수

</details>


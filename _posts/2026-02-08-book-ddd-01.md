---
title: Chapter 1. 도메인 모델 시작하기
date: 2026-02-08
categories: [Book, 도메인 주도 개발 시작하기]
tags: [ddd]     # TAG names should always be lowercase
author: admin
# description: Short summary of the post.  # display on the home page for a list of post
toc: true
comments: false
# https://chirpy.cotes.page/posts/write-a-new-post/
# ⇒, →
---

---
## ► 책 소개
<br/>

![ddd-book-image](/assets/img/books/ddd/ddd-book-cover.jpg){: w="100" h="300" .normal}

**[\[도메인 주도 개발 시작하기\] - 최범균](https://www.aladin.co.kr/shop/wproduct.aspx?ISBN=K262837077&start=pnaver_02)**

DDD 관련해서 볼 일이 있다면 꼭 봐야할 책 중 하나라고 한다. 챕터 2개를 읽어보니 상당히 이해하기 쉽게 잘 작성된 책으로 보인다. 단점은 교과서 같은 재질로 책을 만들어서 책이 무겁다는 것 정도?

저자가 3-4년의 개발 경험이 있다면 내용을 이해하는 것이 좀 더 수월할 것이라고 하는데, 확실히 완전 신입 때 읽었으면 도메인이라는 단어 정의에서부터 막혔을 것 같다. 친구는 듣더니 naver, google 같은 도메인이 아니냐고 묻더라...

스터디 용으로 산 책이기 때문에 앞으로 한 챕터씩 정리해 나갈 예정이다.

<br/>
<br/>

---

## ► Eric Evans
<br/>

이 책은 에릭 에반스의 \<Domain-Driven Design: Tackling Complexity in the Heart of Software> 책을 쉽게 풀어 쓴 내용이라 한다.

유튜브에서 \<My AI Learning Journey>라는 것도 언제 찍으셨는데 제목이 흥미로워 보이니 시간이 되면 봐야겠다. 채널 명도 Domain-Driven Design Europe인데 이런 채널도 있다니 새롭다.

<div class="video-container">
  <iframe
    src="https://www.youtube.com/embed/cR7joaBOXhc"
    allowfullscreen>
  </iframe>
</div>


<br/>
<br/>


---

## 0. DDD란?
<br/>

책을 읽으면서 DDD에 대한 개괄적 이해가 먼저 필요하다고 느꼈다. 책의 내용은 도메인은 무엇이고, 도메인의 구성 요소는 무엇이고, DDD의 아키텍처는 어떤 요소이고, 이를 형성해 나가는 과정에서 무엇이 필요한지 설명을 진행한다.

이러한 설명 방식은 하나씩 따라가기는 좋은데 한번에 큰 그림을 그리기는 어려웠다. 그래서 DDD가 기존 방법과 무엇이 다른데?에 대한 질문이 계속 남았었고, DDD에 대한 설명을 먼저 찾아보기로 했다.

<br/>
<br/>
**우선 위키피디아를 봐보자.**

> 도메인 주도 설계(Domain-Driven Design, DDD)는 해당 도메인의 전문가로부터 얻은 지식을 바탕으로, 소프트웨어를 도메인에 맞게 모델링하는 데 중점을 두는 소프트웨어 설계 접근 방식이다. DDD는 하나의 통합된 단일 모델을 사용하는 방식에 반대하며 ... 각 컨텍스트마다 고유한 모델을 갖도록 구성한다.

> 도메인 주도 설계(Domain-Driven Design, DDD)는 다음과 같은 목표를 기반으로 한다.
 * 프로젝트의 핵심 초점을 핵심 도메인(Core Domain)과 도메인 로직 계층에 두는 것
 * 복잡한 설계를 도메인 모델에 기반하여 구성하는 것
 * 특정 도메인 문제를 해결하기 위한 개념적 모델을 반복적으로 정교화하기 위해, 기술 전문가와 도메인 전문가 간의 창의적 협업을 촉진하는 것

<br/>
<br/>

**위 내용에서 DDD를 이해한 대로 써보자면,**

"내가 만드려는 서비스에서 사용되는 개념을 코드로 구현하자"같다.

그리고 어느 정도는 OOP가 없었다면 나오지 못했을 개념으로 보인다. OOP도 현실의 객체를 코드로 만들어보자는 패러다임이었으니 말이다.

<small>*정말 그런지는 책을 더 읽어봐야 확신하겠지만 말이다.*</small>


<br/><br/>

---


## 1. 도메인(domain)
<br/>

*소프트웨어로 해결하고자 하는 문제 영역이다.*

사실상 **무슨** 혹은 **어떤 분야의** 서비스를 개발할 것인가에 대한 질문이다.<br/>
예를 들면 알라딘과 같은 온라인 서점 서비스를 만들고자 하면 서점이 도메인이다.

이러한 **도메인은 하위 도메인으로 나눌 수 있다.**<br/>
온라인 서점에는 주문, 배송, 회원, 카탈로그, 결제 등의 하위 도메인이 존재한다.

개발자는 도메인 전문가와 대화를 직접 해서 도메인 전문가가 정말 원하는 요구사항이 무엇인지, 이를 어떻게 개발해야할지 고민해야 한다.


<br/><br/>

---

## 2. 도메인 모델 (domain model)

### 2-1. 개념 모델로서의 도메인
<br/>

특정 도메인을 “개념”적으로 표현한 것을 도메인 모델이라고 한다.<br/>
<small>*이 책에서는 도메인, 도메인 모델, 도메인 패턴 등 사방에 도메인이 붙어있어서 suffix를 잘 봐야한다.*</small>

도메인 모델은 **1)주요 데이터**와 **2)기능**으로 구성되어 있다.<br/>
예를 들면 "주문" 도메인에는 주문 번호, 주문자 id 등이 있고, 기능으로는 주문 취소 등이 있다.

<br/>
어디에서 많이 본 것 같지 않은가? OOP의 클래스와 똑같다.<br/>
아래는 위키피디아에서 OOP를 치면 나오는 이미지이다. 버튼을 구성하는 데이터와 기능이 들어있다.<br/>
<small>이러니 OOP와의 연관성이 의심되는 것이다.</small>

![oop image](/assets/img/books/ddd/oop.png){: w="100" h="300" .normal}

<br/>
하지만, 도메인 모델을 표현하는 형태가 **객체 기반 모델인지 함수 기반 모델인지 다이어그램인지는 상관 없다.**라고 한다.
이를 통해 DDD는 OOP와 유사한 개념들이 많지만, OOP보다 한층 더 추상화된 개념이라고 추측해 볼 수 있다.

<br/>
또한, 이 장에서 인상 깊었던 부분 중 하나는 이 지점이었던 것 같다.

>**도메인에 따라 용어 의미가 결정되기 때문에 여러 하위 도메인을 하나의 다이어그램에 모델링하면 안 된다.**
{: .prompt-warning }

예를 들면 카탈로그의 상품과 배송의 상품의 의미는 다르기 때문에 같은 하나의 다이어그램으로 모델링하면 안 된다는 것이다.

```
그런데 내가 여태까지 작성한 코드 패턴을 생각해보면 하나의 통일된 모델로 만들었던 때도 많은 것 같다.
왜냐하면 보통 같은 명칭으로 불리는 경우, 같은 필드를 공유하는 때가 많기 때문이다.
이를 전부 분리해서 하게 된다면 클래스가 무한 증식하게 되는데 고민이 되는 지점으로 보인다.

만약 클래스를 분리한다면 A 도메인의 Product가 B 도메인의 Product로 전환되어야 할 때도 있을 것으로 보이는데
이런 경우에는 convert 하는 메서드를 따로 만드는지도 궁금하다. 아니면 서로 공유하는 인터페이스를 만드는지?

그리고 추후 보면 도메인 별로 패키지를 구분한다고 하는데
com.packagename.A.product, com.packagename.B.product 로 구분하는 것인지
아니면 com.packagename.A.Aproduct, com.packagename.B.Bproduct 이런식으로 작명을 하는지도 궁금하다.
두 클래스가 한 곳에서 쓰이게 되는 일은 없는 것일까?
```

<br/>

### 2-2. 도메인 모델 패턴
<br/>

도메인 모델 패턴은 마틴 파울러의 \<엔터프라이즈 애플리케이션 아키텍처 패턴>에서 나온 개념이다.
아키텍처 상의 도메인 계층을 “객체 지향 기법”으로 구현하는 패턴이라고 한다.

**\<아키텍처 구성>**
* **표현 계층**: 사용자 요청을 처리하고 사용자에게 정보를 보여주는 계층. UI, 소프트웨어를 사용하는 외부 시스템.
* **응용 계층**: 사용자가 요청한 기능을 실행. 업무 로직을 직접 구현하지 않으며 도메인 계층을 조합해서 기능을 실행한다. <small>(?) 정확히 어떤 의미인지 모르겠음. 아마도... 도메인 객체들을 조합해서 기능을 만든다는 의미?</small>
* **도메인 계층**: 시스템이 제공할 도메인 규칙을 구현
* **인프라스트럭처 계층**: 데이터베이스, 메시징 시스템과 같은 외부 시스템과의 연동 처리


<br/><br/>

---

## 3. 도메인의 핵심 규칙 구현
<br/>
각 도메인에는 핵심 비즈니스 규칙이 있고, 코드는 이를 구현해야 한다.<br/>
예를 들면 "주문" 도메인은 출고전에 배송지를 변경할 수 있다, 주문 취소는 배송 전에만 할 수 있다 같은 규칙이 존재한다.

<br/>
핵심 규칙을 구현하는 코드는 도메인 모델에만 위치하기 때문에 **규칙이 바뀌거나 규칙을 확장해야 할 때 다른 코드에 영향을 덜 주고 변경 내역을 모델에 반영할 수 있는 장점**이 있다.

<br/>
```java
public class Order {
    public void cancel() {...}
    public void changeShippingInfo(ShippingInfo newShipping) {...}
}
```

<br/>
```
다른 팀에서 실제로 이렇게 많이 하는지 궁금하다. business logic을 따로 모아서 구현하기도 하지 않나.
> 이게 DDD 패턴은 아닌 것 같음. 다른 무슨 패턴이 있나?

(장점) 깔끔하다. 도메인 만을 위한 기능이라는 느낌이 존재.
(단점) 로직들을 한번에 보기가 어려움. 항상 해당 로직 파일에 들어가서 로직 확인 필요. 지금이야 IDE가 잘 되어있어서 괜찮다지만..

```

<br/><br/>

---

## 4. 도메인의 구성 요소

### 4-1. 엔터티(entity)
* 고유한 식별자가 존재
* 두 엔터티의 식별자가 동일하면 같은 엔터티
* 식별자 생성 시점은 도메인의 특징과 사용하는 기술에 따라 달라짐
    * DB의 auto-increment와 같은 경우, 테이블에 데이터를 추가하기 전에는 식별자를 알 수 없음
    * UUID
    * 현재 시간 + 다른 값 조합
        * (예) 2021112831728afjkel 
        * 같은 시간에 동시에 식별자를 생성해도 같은 식별자가 만들어지면 안 된다.<br/>
        <small>*UUID 같은 것을 놔두고 충돌할 가능성이 있는 식별자를 택할 이유가 무엇인가...?*</small> 

<br/>
### 4-2. 값(value)
* 개념적으로 완전한 하나를 표현. Immutable한 것이 특징
* 의미를 명확하게 표현하기 위해 사용하는 경우도 있음
* 밸류 타입을 위한 기능 추가 가능
* 밸류 객체의 데이터를 변경할 때는 기존 데이터를 변경하기보다는 새로운 객체를 생성
* 스레드에 안전한 코드를 작성하기 위해 + 참조 투명성을 유지하기 위해 필요하다.


<br/><br/>

---

## 5. 도메인 모델에 set 메서드를 습관적으로 넣지 않기
<br/>
setter는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다. 왜냐하면 setter는 단순히 상태값만 변경할지 아니면 상태값에 따라 다른 처리를 위한 코드를 함께 구현할지 애매할 때가 많기 때문이다.

setter를 한다면 private 접근자를 사용하고, 클래스 내부에서 데이터를 변경할 목적으로만 사용해야 한다.

또한, 도메인 객체를 생성할 때 setter를 통해 필드를 채우는 것이 아니라, 생성자를 통해 필요한 데이터를 모두 받아야 한다.

```
다른 곳에서는 setter에 대해 어떤 정책을 가져가고 있는지도 개인적으로 궁금하다.
현재 프로젝트에서는 jackson을 이용해 모델을 copy하고 있기 때문에 setter가 꼭 있어야만 해서,
setter를 사실상 피할 수 없다.
```


<br/><br/>

---

## 6. 유비쿼터스 언어
<br/>
전문가, 관계자, 개발자가 도메인과 관련된 공통의 언어를 만들고 이를 대화, 문서, 도메인 모델, 코드, 테스트 등 모든 곳에서 같은 용어를 사용해야 한다고 한다. 소통 과정에서 발생하는 용어의 모호함을 줄이기 위해서라고 한다.

개발자는 도메인과 코드 사이에서 불필요한 해석을 줄일 수 있다.

추가로 유비쿼터스 언어에 대해 마틴 파울러가 작성한 글이 있다.<br/>
→ <a href="https://martinfowler.com/bliki/UbiquitousLanguage.html">ubiquitous language</a>

<br/>
```
그런데 초기부터 너무 용어 논의만 하다가 개발할 시간은 어디론가 가버릴지도...? 
그리고 한 서비스를 구성하는 팀이 많다면 모든 용어에 대해 정의할 수 없기 때문에
어느 순간 분명히 서로 다른 용어를 사용하는 곳이 나오리라 본다.
그리고 예를 들어 넷플릭스 같은 곳을 생각해보면 다양한 종류의 추천을 유저에게 추천하고 있다.
이때 각 추천 영역을 하나하나 구분하려하고 도메인을 반영하려고 하면 머리가 아프지 않을까... 실제로 그랬다.
이게 현실적으로 실현가능한지는 모르겠으나 되도록이면 공통된 용어를 쓰자는 것 자체는 좋은 의견 같다.
```